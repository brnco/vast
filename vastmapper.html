<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
</head>
<body>
<div id="plane">
</div>
<input id="north" type="button" value="north" style="visibility:hidden;" onclick="loadImg('n')"/>
<input id="south" type="button" value="south" style="visibility:hidden;" onclick="loadImg('s')"/>
<input id="east" type="button" value="east" style="visibility:hidden;" onclick="loadImg('e')"/>
<input id="west" type="button" value="west" style="visibility:hidden;" onclick="loadImg('w')"/>
<script>



/*

vast

*/
function vast(number){
	return "vast" + number.toString();
}



/*

setImage

puts a new image on the page
//$('#plane').css("background-image","url(" + imgpath+ ")");
//$('#plane').load(imgpath + ' #plane');

*/
function setImg(img){
	//path context for generating paths to the images
	var rootContext = "/vastmapper";
	var imgpath = rootContext + '/images/' + img + '.png';
	var image = new Image();
	image.src = imgpath;
	image.onload = function() {
		$('#plane').empty().append(image);
	}
}


/*

nextChecker

takes input vastNum and figues out if it's eligible to add to the neighborhood
vastNum is eligible if:
1) it is not already assigned to the directionTo another vastNumber in themap
2) not the first tile
3) that it can link back to its potential neighbor

*/

function nextChecker(sourceImagesObj, vastNumKey, direction, neighborIndex, oppositeDirection, theMap){
	var thisVastsNeighborhood = theMap[vastNumKey];
	var thisVast = vast(neighborIndex);
	for (var vnk in theMap){
		for (var thisVastsNeighborDirection in thisVastsNeighborhood){
			var thisVastsNeighbor = thisVastsNeighborhood[thisVastsNeighborDirection];
			if (thisVastsNeighbor == thisVast){
				return false;
			}
		}
	}
	if (thisVast == vastNumKey){
		return false;
	} else if (sourceImagesObj[thisVast].indexOf(oppositeDirection[direction])<0){
		return false;
	} else {
		return true;
	}
}




/*

setStartObj

creates an initial {"n":"vast123","s":"vast45"} object

*/
function setStartObj(startImg,sourceImagesObj,oppositeDirection,theMap){
	//build a neighborhood for the startImg
	var neighborhood = {};
	for (var directionIndexFromStartImg in sourceImagesObj[startImg]){
		var direction = sourceImagesObj[startImg][directionIndexFromStartImg];
		var output = false;
		while (output == false){
			var neighborIndex = Math.floor(Math.random() * 247) + 12;
			output = nextChecker(sourceImagesObj, startImg, direction, neighborIndex, oppositeDirection, theMap);
		};
		var neighbor = vast(neighborIndex);
		neighborhood[direction] = neighbor;
	}
	return neighborhood;
}




/*

makeNeighbor

returns a vastNum for supplied direction based on rules

*/
function makeNeighbor(sourceImagesObj,home,DIR,oppositeDirection,directionFromHome,neighborAtDirectionFromHome,theMap){
	if (DIR == oppositeDirection[directionFromHome]){
		var neighbor = home;
		//alert("eyyy");
	} else {
		var output = false; //init
		count = 0; //init
		while ((output == false) && (count < 100)){
			var neighborNumber = Math.floor(Math.random() * 247) + 12;
			output = nextChecker(sourceImagesObj,neighborAtDirectionFromHome, DIR, neighborNumber, oppositeDirection, theMap);
			count = count + 1;
		}
		if (count < 99){
			count = 0;
			var neighbor = vast(neighborNumber); //convert index to vastNum tile
		} else {
			var neighbor = null;
		}
	}
	return neighbor;
}




/*

addNeighborhoodsToTheMap

loops thru diff, grips neighbors at each directions
for each neighbor at each direction
loops through directions available to neighbor
generates new neighbor at that direction
links old neighbor back at the opposite direction
assigns neighborhood to themap

*/
function addNeighborhoodsToTheMap(theMap,diff,sourceImagesObj,oppositeDirection){
	for (vnIndex in diff){ //for vastNumberIndex in list of images that were added
		var home = diff[vnIndex]; //vast number for item in themap we'd like to loop thru. home has a neighborhood already
		for (var directionFromHome in theMap[home]){ //for directions available in current tile
			var neighborAtDirectionFromHome = theMap[home][directionFromHome]; //the vastNum at a direction for the tile in the diff
			console.log(neighborAtDirectionFromHome);
			if (theMap[neighborAtDirectionFromHome]){ continue; } else {
				var neighborhood = {}; //init
				var directionsAvailableToNeighbor = sourceImagesObj[neighborAtDirectionFromHome]; //string nsew for directions available in this tile
				for (directionIndex in directionsAvailableToNeighbor){ //loop thru directions available for this tile, directionIndex = "1""2""3""4" for "nsew"
					var DIR = directionsAvailableToNeighbor[directionIndex]; //the direction we're assigning right now, "n" = "nsew"[0]
					neighbor = makeNeighbor(sourceImagesObj,home,DIR,oppositeDirection,directionFromHome,neighborAtDirectionFromHome,theMap);
					if (!neighbor){
						//diff[0] == null;
						return theMap;	 
					}
					neighborhood[DIR] = neighbor; //add this direction:tile pair to the dictionary
				}	
				theMap[neighborAtDirectionFromHome] = neighborhood; //add the list of neighbor tiles to the map at the key[vastNum]
			}		
		}
	}
	return theMap
}






/*

loads the bottons with every new image
toggles button visibility based on the image's available directions in the map

*/
function loadButtons(){
	var currentImg = $('#plane').children("img").prop('src');
	console.log(currentImg);
	var myRe = /vast\d{1,}/; //make a regex pattern to grip just the vast123 part
	var result = myRe.exec(currentImg); //run that pattern against the url
	var vastImg = result[0];
	var vastImgDirsObj = Vast.theMap[vastImg];
	vastImgDirs = Object.keys(vastImgDirsObj);
	//console.log(foo);
	if (vastImgDirs.includes("n") && Vast.theMap[vastImg]["n"] != null){
		$('#north').css('visibility','visible');
	}
	if (vastImgDirs.includes("s") && Vast.theMap[vastImg]["s"] != null){
		$('#south').css('visibility','visible');
	}
	if (vastImgDirs.includes("e") && Vast.theMap[vastImg]["e"] != null){
		$('#east').css('visibility','visible');
	}
	if (vastImgDirs.includes("w") && Vast.theMap[vastImg]["w"] != null){
		$('#west').css('visibility','visible');
	}
}


/*

loadImg

loads a new image to #plane on input of a button
new image loaded corresponds to direction pressed by
button, "north" "south" "east" "west"
as delineated by the map

*/
function loadImg(directionTo){
	directionFrom = Vast.oppositeDirection[directionTo];
	var currentImg = $('#plane').children("img").prop('src');
	//console.log(currentImg);
	var myRe = /vast\d{1,}/; //make a regex pattern to grip just the vast123 part
	var result = myRe.exec(currentImg); //run that pattern against the url
	var currentImg = result[0];
	if (Vast.theMap[currentImg] != null){
		newImg = Vast.theMap[currentImg][directionTo];
		setImg(newImg);
		setTimeout(loadButtons(),100)
	}
}

var Vast = {};
$(document).ready(function(){
	/*
	init
	this array contains a json file
	that is made into an array
	the array has key values for the 
	"vastNumber":"stringDirectionNSEW"
	so. {"vast123":"nsw","vast456":"nsew"}
	*/
	var sourceImagesObj = (function() {
		var sourceImagesObj = null;
		$.ajax({
			'async': false,
			'global': false,
			'url': "images.json",
			'dataType': "json",
			'success': function (data) {
				json = data;
			}
		});
		return json;
	})();

	//init array for opposite_direction values
	var oppositeDirection = {
		"n":"s",
		"s":"n",
		"e":"w",
		"w":"e"
	}
	Vast.oppositeDirection = oppositeDirection;
	//make a random starting img
	//var imgObjKeys = Object.keys(sourceImagesObj);
	var startImgIndex = Math.floor(Math.random() * 247) + 12;
	var startImg = vast(startImgIndex);
	setImg(startImg);

	//assign init image to plane
	$('#plane').css({
		height:"300px",
		width:"300px",
		backgroundRepeat: "no-repeat",
		backgroundSize:"cover"
		//backgroundSize:"320px 190px"
	});
	
	//init map stuff
	var theMap = {};
	var a = Object.keys(theMap);
	var neighborhood = {};
	neighborhood = setStartObj(startImg,sourceImagesObj,oppositeDirection,theMap);
	theMap[startImg] = neighborhood;
	var diff = Object.keys(theMap)
	console.log(theMap);
	
	
	/*

	map generation

	starts with the diff of the previous map and the current map
	sends the map and the diff to addNeighborhoodsToTheMap
			
	*/
	mapgeneration:
	while (diff[0]){
		a = Object.keys(theMap); //assign array to the tiles currently in
		theMap = addNeighborhoodsToTheMap(theMap,diff,sourceImagesObj,oppositeDirection);
		var diff = Object.keys(theMap).filter(function(x) { return a.indexOf(x) < 0});
	}
	delete theMap["undefined"];
	console.log(theMap);
	Vast.theMap = theMap;
	setTimeout(function(){
		loadButtons();
	},2000);
});	
</script>
</body>
</html>