<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
</head>
<body>
<div id="plane">
</div>
<input id="north" type="button" value="north" style="visibility:hidden;" onclick="loadImg('n')"/>
<input id="south" type="button" value="south" style="visibility:hidden;" onclick="loadImg('s')"/>
<input id="east" type="button" value="east" style="visibility:hidden;" onclick="loadImg('e')"/>
<input id="west" type="button" value="west" style="visibility:hidden;" onclick="loadImg('w')"/>
<script>



/*

vast

*/
function vast(number){
	return "vast" + number.toString();
}



/*

setImage

puts a new image on the page
//$('#plane').css("background-image","url(" + imgpath+ ")");
//$('#plane').load(imgpath + ' #plane');

*/
function setImg(img){
	var rootContext = "/vastmapper"; //path context for generating paths to the images
	var imgpath = rootContext + '/images/' + img + '.png';
	var image = new Image();
	image.src = imgpath;
	image.onload = function() {
		$('#plane').empty().prepend(image);
	}
}


/*

nextChecker

takes input vastNum and figues out if it's eligible to add to the neighborhood
vastNum is eligible if:
1) it is not already assigned to the directionTo another vastNumber in themap
2) not the first tile
3) that it can link back to its potential neighbor

*/
function nextChecker(sourceImagesObj, vastNumKey, direction, neighborIndex, oppositeDirection, theMap){
	var thisVastsNeighborhood = theMap[vastNumKey]; //get neighborhood for current tile
	var thisVast = vast(neighborIndex); //convert supplied random 123 number to vast123
	for (var vnk in theMap){ //loop thru the vast number keys (vnk = "vast123","vast124",etc) in theMap
		for (var thisVastsNeighborDirection in thisVastsNeighborhood){ //loop thru keys "n","s","e","w" available to current tile
			var thisVastsNeighbor = thisVastsNeighborhood[thisVastsNeighborDirection]; //get the neighbor at that direction
			if (thisVastsNeighbor == thisVast){ //if neighbor at direction == supplied random vastNum
				return false;
			}
		}
	}
	if (thisVast == vastNumKey){ //if it's the same random number as the current tile
		return false;
	} else if (sourceImagesObj[thisVast].indexOf(oppositeDirection[direction])<0){ //if we can't link this tile back to the previous tile
		return false;
	} else {
		return true;
	}
}




/*

setStartObj

creates an initial {"n":"vast123","s":"vast45"} object
see makeNeighbor for comments

*/
function setStartObj(startImg,sourceImagesObj,oppositeDirection,theMap){
	var neighborhood = {}; //init
	for (var directionIndexFromStartImg in sourceImagesObj[startImg]){
		var direction = sourceImagesObj[startImg][directionIndexFromStartImg];
		var output = false;
		while (output == false){
			var neighborIndex = Math.floor(Math.random() * 247) + 12;
			output = nextChecker(sourceImagesObj, startImg, direction, neighborIndex, oppositeDirection, theMap);
		};
		var neighbor = vast(neighborIndex);
		neighborhood[direction] = neighbor;
	}
	return neighborhood;
}




/*

makeNeighbor

returns a vastNum for supplied direction based on rules

*/
function makeNeighbor(sourceImagesObj,home,DIR,oppositeDirection,directionFromHome,neighborAtDirectionFromHome,theMap){
	if (DIR == oppositeDirection[directionFromHome]){ //if the direction we're assigning a neighbor to is the opposite of the direction we're coming from
		var neighbor = home; //links the new neighbor to the old neighbor
	} else {
		var output = false; //init
		count = 0; //init
		while ((output == false) && (count < 100)){
			var neighborNumber = Math.floor(Math.random() * 247) + 12; //generate 123 part of vast123
			output = nextChecker(sourceImagesObj,neighborAtDirectionFromHome, DIR, neighborNumber, oppositeDirection, theMap); //make sure we can use this vast123
			count = count + 1;
		}
		if (count < 99){
			count = 0;
			var neighbor = vast(neighborNumber); //convert index to vastNum tile
		} else {
			var neighbor = null; //means that we've run out of new neighbors that we can use. end condition
		}
	}
	return neighbor;
}




/*

addNeighborhoodsToTheMap

loops thru diff, grips neighbors at each directions
for each neighbor at each direction
loops through directions available to neighbor
generates new neighbor at that direction
links old neighbor back at the opposite direction
assigns neighborhood to themap

*/
function addNeighborhoodsToTheMap(theMap,diff,sourceImagesObj,oppositeDirection){
	for (vnIndex in diff){ //for vastNumberIndex in list of images that were added
		var home = diff[vnIndex]; //vast number for item in themap we'd like to loop thru. home has a neighborhood already
		for (var directionFromHome in theMap[home]){ //for directions available in current tile
			var neighborAtDirectionFromHome = theMap[home][directionFromHome]; //the vastNum at a direction for the tile in the diff
			if (theMap[neighborAtDirectionFromHome]){ continue; } else {
				var neighborhood = {}; //init
				var directionsAvailableToNeighbor = sourceImagesObj[neighborAtDirectionFromHome]; //string nsew for directions available in this tile
				for (directionIndex in directionsAvailableToNeighbor){ //loop thru directions available for this tile, directionIndex = "1""2""3""4" for "nsew"
					var DIR = directionsAvailableToNeighbor[directionIndex]; //the direction we're assigning right now, "n" = "nsew"[0]
					neighbor = makeNeighbor(sourceImagesObj,home,DIR,oppositeDirection,directionFromHome,neighborAtDirectionFromHome,theMap);
					if (!neighbor){
						return theMap; //diff function will evaluate theMap as the same theMap that was	 passed to this function, diff[0] will = null
					}
					neighborhood[DIR] = neighbor; //add this direction:tile pair to the dictionary
				}	
				theMap[neighborAtDirectionFromHome] = neighborhood; //add the list of neighbor tiles to the map at the key[vastNum]
			}		
		}
	}
	return theMap
}




/*

loads the bottons with every new image
toggles button visibility based on the image's available directions in the map

*/
function loadButtons(){
	var currentImg = $('#plane').children("img").prop('src');
	var myRe = /vast\d{1,}/; //make a regex pattern to grip just the vast123 part
	var result = myRe.exec(currentImg); //run that pattern against the url
	var vastImg = result[0]; //get first index of object returned by regex = vast123
	var vastImgDirsObj = Vast.theMap[vastImg]; //get the vastNum object from theMap vast123{"n":"vast124","s":"vast125"}
	vastImgDirs = Object.keys(vastImgDirsObj); //get just a list of the directions ["n","s","e","w"]
	if (Vast.theMap[vastImg]["n"]){
		$('#north').css('visibility','visible');
	} else {
		$('#north').css('visibility','hidden');
	}
	if (Vast.theMap[vastImg]["s"]){
		$('#south').css('visibility','visible');
	} else {
		$('#south').css('visibility','hidden');
	}
	if (Vast.theMap[vastImg]["e"]){
		$('#east').css('visibility','visible');
	} else {
		$('#east').css('visibility','hidden');
	}
	if (Vast.theMap[vastImg]["w"]){
		$('#west').css('visibility','visible');
	} else {
		$('#west').css('visibility','hidden');
	}
}


/*

loadImg

loads a new image to #plane on input of a button
new image loaded corresponds to direction pressed by
button, "north" "south" "east" "west"
as delineated by the map

*/
function loadImg(directionTo){
	directionFrom = Vast.oppositeDirection[directionTo];
	var currentImg = $('#plane').children("img").prop('src'); //img that is currently displayed
	var myRe = /vast\d{1,}/; //make a regex pattern to grip just the vast123 part
	var result = myRe.exec(currentImg); //run that pattern against the url
	var currentImg = result[0];
	if (Vast.theMap[currentImg] != null){
		newImg = Vast.theMap[currentImg][directionTo];
		setImg(newImg);
		setTimeout(function(){
			loadButtons();
		},1000);	
	}
}

//init namespace object to store global theMap and oppositeDirection objects
var Vast = {};

$(document).ready(function(){
	/*
	init
	the array has key values for the 
	"vastNumber":"stringDirectionNSEW"
	so. {"vast123":"nsw","vast456":"nsew"}
	*/
	var sourceImagesObj = (function() {
		var sourceImagesObj = null;
		$.ajax({
			'async': false,
			'global': false,
			'url': "images.json",
			'dataType': "json",
			'success': function (data) {
				json = data;
			}
		});
		return json;
	})();

	//init array for opposite_direction values
	var oppositeDirection = {
		"n":"s",
		"s":"n",
		"e":"w",
		"w":"e"
	}
	//assign to global namespace object
	Vast.oppositeDirection = oppositeDirection;
	
	//make a random starting img
	//var imgObjKeys = Object.keys(sourceImagesObj);
	var startImgIndex = Math.floor(Math.random() * 247) + 12;
	var startImg = vast(startImgIndex);
	setImg(startImg);

	//assign init image to plane
	//backgroundRepeat: "no-repeat",
	//backgroundSize:"cover"
	//backgroundSize:"320px 190px"
	$('#plane').css({
		height:"500px",
		width:"500px",
		objectFit:"fill"
	});
	
	//init map stuff
	var theMap = {};
	var a = Object.keys(theMap);
	var neighborhood = {};
	neighborhood = setStartObj(startImg,sourceImagesObj,oppositeDirection,theMap);
	theMap[startImg] = neighborhood;
	var diff = Object.keys(theMap)
	console.log(theMap);
	
	
	/*
	fill the map
	starts with the diff of the previous map and the current map
	sends the map and the diff to addNeighborhoodsToTheMap	
	*/
	while (diff[0]){
		a = Object.keys(theMap); //assign array to the tiles currently in
		theMap = addNeighborhoodsToTheMap(theMap,diff,sourceImagesObj,oppositeDirection);
		var diff = Object.keys(theMap).filter(function(x) { return a.indexOf(x) < 0});
	}
	//console.log(theMap);
	//assign the completed theMap to the global namespace object
	Vast.theMap = theMap;
	
	//breathe, then load the buttons
	setTimeout(function(){
		loadButtons();
	},2000);
});	
</script>
</body>
</html>